<!DOCTYPE html>
<html>
<head>
	<title>Временная сложность</title>
	<style>
		html, * {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			min-height: 100vh;
			background: lightgreen;
		}

		.grid {

		}

		p:nth-child(1) {
			padding: 20px;
			text-align: center;
			font-family: ubuntu;
			font-weight: bolder;
			font-size:40px;
			color: white;
			font-weight: bolder;
			text-shadow: -2px 5px 3px rgba(0, 0, 0, .2);
			text-transform: uppercase;
		}

		.blog {
			margin: 10px auto;
			max-width: 800px;
			/*background: white;*/
			text-align: center;
		}

		.blog__heading {
			text-align: left;
			font-size: 29px;
			text-transform: capitalize;
			font-weight: bolder;
			color: #444;
			padding: 5px;
		}
		.blog .survey__image {
			width: 700px;
			margin: 15px auto;
		}

		.survey_explain{
			text-align: justify;
			margin: 30px auto;
			padding: 5px;
			font-size: 24px;
			color: #555;
			font-weight: normal;
			line-height: 30px;
		}

		.each_header{
			text-transform: capitalize;
			font-size: 28px;
		}

		.o_notations {
			margin: 20px auto;
		}

		.o_notations > div {
			margin: 30px auto;
		}

		.o_notations > div > .head {
			color: #444;
			font-size: 30px;
			font-weight: bolder;
		}

		.big__each__explaination {

			font-size: 20px;
		}
		.doc {
			font-size: 25px;
			font-weight: normal;
			padding: 20px 0px;
		}

		code > pre {
			font-size: 15px;
			background: black;
			padding: 10px;
			color: white;
			border-radius: 10px;
			box-shadow: 5px 5px 8px rgba(0, 0, 0, .9);
		}

		.list {
			position: relative;
			left: 30px;
		}
		
		.image_ext {
			position: relative;
			display: flex;
			justify-content: center;
			padding: 10px 0px;
		}


	</style>
	<meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
</head>
<body>
	<p>Сложность по времени</p>
<div class='grid'>
    <div class="blog">
        <h3 class="blog__heading">Что такое сложность по времени и зачем она нужна?</h3>
        <div class="blog_why">
            <img class="survey__image" alt="survey" src="../images/survey.gif">
            <div class="survey_explain">
                Давайте попробуем понять это на примере гражданского инженера. Когда инженер проводит обследование, ему нужно учитывать определенные стандартные параметры. Например, если его попросят определить, является ли данная <b>цементная смесь</b> хорошей для использования на строительной площадке, он будет учитывать такие параметры, как <b>соотношение воды, заполнителей, песка</b> и т.д. 

                Но когда речь идет о <b>инженере в области компьютерных наук</b>, его работа заключается в анализе кода. И если инженера-программиста попросят сказать, хороший ли данный фрагмент кода, то ответом на этот вопрос будет понятие
                <b>Сложности по времени и пространству (памяти)</b>.
            </div>
            <img class="survey__image" alt="time_space_complexity" src="../images/time_space_complexity.png">
            <div class="survey_explain">
                <b>Определение:</b>&nbsp; 
                Сложность по времени алгоритма количественно определяет количество времени, необходимое для его выполнения в зависимости от длины входных данных. Аналогично, сложность по пространству определяет количество памяти, требуемое для выполнения алгоритма в зависимости от размера входных данных.
            </div>

            <div class="survey_explain">
                <b class="each_header">У нас есть три асимптотических обозначения для расчета сложности по времени</b>
                <div class="o_notations">
                    <div class="big_θ_notation">
                        <b class="head">1. Обозначение Большое-Θ (Большое-Тета)</b>
                        <div class="big__each__explaination">

                            <p class="doc">
                                Рассмотрим простую реализацию линейного поиска:
                            </p>
                            <code>
                                <pre>
var doLinearSearch = function(array, targetValue) {
  for (var guess = 0; guess < array.length; guess++) {
    if (array[guess] === targetValue) { 
        return guess;  // найдено!
    }
  }
  return -1;  // не найдено
};
                                </pre>
                            </code>		
                            <p class="doc">
                                Обозначим размер массива (array.length) как n. Максимальное количество выполнений цикла for — n, и этот худший случай происходит, когда искомое значение отсутствует в массиве.
                            </p>
                            <p class="doc">
                                На каждой итерации цикла выполняются следующие действия:
                                <ul class="list">
                                    <li>сравнение guess с array.length</li>
                                    <li>сравнение array[guess] с targetValue</li>
                                    <li>возможный возврат значения guess</li>
                                    <li>увеличение guess на 1</li>
                                </ul>
                            </p>
                            <p class="doc">
                                Каждое из этих действий требует постоянного времени. Следовательно, если цикл выполняется <i>n</i> раз, общее время будет <i>c1*n</i>, где <i>c1</i> — сумма времён выполнения всех действий в одной итерации. 
                                Точное значение <i>c1</i> зависит от скорости компьютера, языка программирования, компилятора или интерпретатора и других факторов.
                            </p>

                            <p class="doc">
                                Дополнительно есть небольшие накладные расходы на установку цикла for (например, инициализация guess = 0) и возможный возврат -1 в конце. Назовем это время <i>c2</i>, оно также константно. 
                                Таким образом, общее время в худшем случае: <i>c1*n + c2</i>.
                            </p>

                            <p class="doc">
                                Однако константы <i>c1</i> и <i>c2</i> не влияют на темп роста времени выполнения. Самое важное, что время работы линейного поиска в худшем случае растет пропорционально размеру массива <i>n</i>. Мы записываем это как <i>Θ(n)</i>.
                            </p>

                            <p class="doc">
                                Если говорим, что время выполнения равно <i>Θ(n)</i>, это означает, что для достаточно больших n время выполнения находится между <i>k1*n</i> и <i>k2*n</i> для некоторых констант <i>k1</i> и <i>k2</i>.
                            </p>
                            <p class="image_ext">
                                <img src="../images/time_thetha.png" alt="theta" class="time_image">
                            </p>
                            <p class="doc">
                                Для малых значений n это неважно, но начиная с определенного момента — время должно находиться между этими двумя границами.
                            </p>
                            <p class="doc">
                                Можно использовать и другие функции вместо <i>n</i> в обозначении Θ, например, <i>n²</i>, <i>n log n</i> и так далее.
                            </p>
                            <p class="image_ext">
                                <img src="../images/time_thetha_1.png" alt="theta" class="time_image">
                            </p>
                            <p class="doc">
                                При этом мы отбрасываем константные множители и слагаемые низших порядков.
                            </p>
                            <p class="doc">
                                Использование большого-Θ означает, что мы нашли <b>асимптотически точную границу</b> времени выполнения.
                            </p>

                        </div>
                    </div>

                    <div class="big_o_notation">
                        <b class="head">2. Обозначение Большое-O (Большое-О)</b>
                        <div class="big__each__explaination">

                            <p class="doc">
                                Иногда нам нужно только ограничение сверху. Например, хотя худшее время работы бинарного поиска — это <i>Θ(log₂n)</i>, в лучшем случае (при первой попытке) он работает за <i>Θ(1)</i>.
                            </p>
                            <p class="doc">
                                Поэтому вводится обозначение Большое-O для указания только верхней границы роста времени выполнения.
                            </p>

                            <p class="doc">
                                Если время выполнения — <i>O(f(n))</i>, значит, для больших n оно не превышает <i>k*f(n)</i> для некоторой константы k.
                            </p>
                            <p class="image_ext">
                                <img src="../images/big_oh.png" alt="big-oh" class="time_image">
                            </p>
                            <p class="doc">
                                Используем Большое-O для указания <b>асимптотической верхней границы</b>.
                            </p>
                            <p class="doc">
                                Например, бинарный поиск всегда выполняется за <i>O(log₂n)</i>.
                            </p>
                            <p class="doc">
                                Но стоит помнить: если мы говорим <i>O(f(n))</i>, это менее строго, чем <i>Θ(f(n))</i>.
                            </p>

                            <p class="doc">
                                Интересный момент: мы можем технически сказать, что бинарный поиск работает за <i>O(n)</i> — это правда, но очень неточно (ведь реальное время меньше).
                            </p>

                            <p class="doc">
                                Это как сказать: "У меня в кармане сумма, не превышающая миллион долларов", даже если у вас всего 10 долларов.
                            </p>

                        </div>
                    </div>

                    <div class="big_om_notation">
                        <b class="head">3. Обозначение Большое-Ω (Большое-Омега)</b>
                        <div class="big__each__explaination">

                            <p class="doc">
                                Иногда нам нужно сказать, что алгоритм занимает <b>не менее</b> определенного времени — без указания верхней границы. Для этого используют обозначение Большое-Ω.
                            </p>
                            <p class="doc">
                                Если время выполнения — <i>Ω(f(n))</i>, это значит, что для больших n оно будет как минимум <i>k*f(n)</i> для некоторой константы k.
                            </p>
                            <p class="image_ext">
                                <img src="../images/big_ohm.png" alt="big-omega" class="time_image">
                            </p>

                            <p class="doc">
                                Большое-Ω используется для указания <b>асимптотической нижней границы</b>.
                            </p>

                            <p class="doc">
                                Например, худшее время бинарного поиска можно описать как <i>Ω(log₂n)</i>.
                            </p>
                            <p class="doc">
                                Также можно корректно, но неточно сказать, что бинарный поиск занимает не менее <i>Ω(1)</i> времени (константное время).
                            </p>

                            <p class="doc">
                                Обычно стараются указывать максимально точные оценки сложности, но понимание всех обозначений (Θ, O, Ω) важно для правильного описания алгоритмов.
                            </p>

                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Основной скрипт
</script>
</body>
</html>
